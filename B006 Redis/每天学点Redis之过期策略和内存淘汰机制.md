# 过期策略和内存淘汰机制

## 过期策略

Redis是使用**定期删除**+**惰性删除**两者配合的过期策略。

### 定时删除

每个设置过期时间的key都需要创建一个定时器，到过期时间就会立即清除。该策略可以立即清除过期的数据，对内存很友好；但是会占用大量的CPU资源去处理过期的数据，从而影响缓存的响应时间和吞吐量。

### 定期删除

主动随机删除

指的是Redis默认每隔100ms就**随机抽取**一些设置了过期时间的key，检测这些key是否过期，如果过期了就将其删掉。

每隔一定的时间，会扫描一定数量的数据库的expires字典中一定数量的key，并清除其中已过期的key。该策略是前两者的一个折中方案。通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使得CPU和内存资源达到最优的平衡效果。

缺点：随机性，部分过期的数据无法删除

### 惰性删除

被动检测删除

在客户端要获取某个key的时候，Redis会先去检测一下这个key是否已经过期，如果没有过期则返回给客户端，如果已经过期了，那么Redis会删除这个key，不会返回给客户端。

只有当访问一个key时，才会判断该key是否已过期，过期则清除。该策略可以最大化地节省CPU资源，却对内存非常不友好。极端情况可能出现大量的过期key没有再次被访问，从而不会被清除，占用大量内存。

优点：解决部分未被随机删除的数据



定期+惰性删除缺陷：即没有被随机删除且长期不访问的过期数据

## 内存淘汰机制

当内存达到某个阈值（配置项：`maxmemory`）的时候，就会触发内存淘汰机制，选取一些key来删除。

### 淘汰策略

配置项：` maxmemory-policy`，主要策略有如下几种：

- volatile-lru：在设置过期时间的数据中淘汰最少使用的数据。

- allkeys-lru：在所有的数据中淘汰最少使用的数据。

- volatile-lfu：在设置过期时间的数据中淘汰使用频率最低的数据。

- allkeys-lfu：在所有的数据中淘汰使用使用频率最低的数据。

- volatile-random：在设置过期时间的数据中淘汰任意随机数据。

- allkeys-random：在所有的数据中随机淘汰数据。

- volatile-ttl：在设置过期时间的数据中淘汰最早过期的数据。

- noeviction：默认策略，不淘汰数据，新增或者修改数据会抛异常，但是读操作正常进行，不受影响



- noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。**默认策略**
- volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key。
- allkeys-lru：在所有的数据中淘汰最少使用的数据。
- allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key。
- 在所有的数据中淘汰使用使用频率最低的数据。
- volatile-lfu：在设置过期时间的数据中淘汰使用频率最低的数据。
- volatile-random：在设置过期时间的数据中淘汰最少使用的数据。
- volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除。

### 如何选取策略？

**比较推荐的是两种lru策略**。根据自己的业务需求。如果你使用Redis只是作为缓存，不作为DB持久化，那推荐选择allkeys-lru；如果你使用Redis同时用于缓存和数据持久化，那推荐选择volatile-lru。

> LRU是Least Recently Used的缩写，即最近最少使用。LRU源于操作系统的一种页面置换算法，选择最近最久未使用的页面予以淘汰。在Redis里，就是选择最近最久未使用的key进行删除。



内存淘汰策略用于处理**内存不足**时的需要申请额外空间的数据；过期策略用于处理过期的缓存数据。